'''
  무조건 붙는다!
  코딩 팁들을 모아놓는 장소
  코딩 테스트 전에 꼭 보고 가자
'''

0. 코드 작성, 알고리즘 고민 전에 무조건 '이게 맞나?' 생각
1. 알고리즘을 다 짰다면, 그 다음은 실수 싸움이다. 무조건 머리로 함수 생각해보고 작성할 것.
2. (파이썬 기준) 1초: 2000만 연산 이하, 4MB: 리스트 100만
3. itertools 사용 가능한지 확인해보기. bisect도
4. DP: 점화식 찾는게 핵심. 가장 작은 단위의 답을 어떻게 구할 것인가에 집중하기
5. 방문처리, 데이터 추출, 삽입을 제대로 했는지 코드 적을 때 확인 하자
6. 오류 찾을땐 무작정 X 체크리스트를 생각하고 찾자****(체크 리스트는 팁 정리하면서 생각하기)
7. 최소, 최대값 갱신 타이밍 빼먹지 않고 모두 했는지?(값이 바뀌는 타이밍, 완성된 값 파악하는지 확인)
8. 모든 케이스에서 통하는지: 특이한 지점 위주로 찾기.
9. 혹은 아예 전부 통하는 알고리즘 만들기(검증 필요)
10. 최대, 최소 초기화는 최소, 최대로
11. 값을 변경할 땐 혹시 중복해서 바꾸는건 아닌지(현재 바꾸는 값이 예전에 설정한 값과 겹치는데, 이를 건들면 안되는 경우) 확인하자!
12. 2차원 배열의 겹겹의 테두리 길이는 가장 바깥이 최소공배수가 아니다. -4씩 줄어드는데 이것이 배수임을 보장하지 않는다.
    마찬가지로 어떤 배열이나 모양이 다른 것을 포함한다고 해서 가장 바깥이 모든걸 포함하는게 아니다. 이것을 명심하고 각각의
    값들이 정확히 어떤 성질인지 다 파악해야 한다.
13. ZeroDivisionError 는 div, mod 모두 해당한다.
14. 규모가 큰 코딩은 실수를 하면 찾기 힘들다. 한 번 적을 때 신나서 끝내지 말고, 잘못 적은게 있는지 지나온 길을 다시 보자.
15. 만약 여러 변수의 방문을 체크할 때 변수의 합이 일정하면(특정 조건을 만족하며 유지되면) 한개 이상의 변수를 체크하지 않아도 된다. ex) a + b + c 가 일정하면 c 의 값은
    a, b 에 의해 결정되니 최적화가 필요한 경우 굳이 저장할 필요 없다.
16. 우선순위 큐는 거의 모든 연산에서 log(n)이 소모됨. 시간이 넉넉하다면 상관없지만, 시간이 부족하다면 차라리 정렬이 필요한 순간에만 하는 것이 최적화에 좋음.
17. 시간복잡도를 줄이려면 정렬할 것을 나눠서 정렬하거나 분할정복 해도 가능?
18. 벽을 튕기는 작업은 벽을 뚫고 지나간다고 생각 해보자. 길이 l 만큼 넘어 벽과 부딪히면 그 후부턴 l - 1의 주기로 변화한다(벽 튕기고 반대로 간다는 가정 하에).
19. 문제를 잘 읽고, 내가 평소 사용하는 방식으로 교정해서 쓸 건지, 문제 따를건지 선택.
20. 설계시 경계값 등의 추론은 명확하게 한다. 안되며 그 때 임시적 최대값 ex) 987654321 등 사용
21. 뭔가 나눌 땐(나머지 계산도 마찬가지) 항상!! ZeroDivision 확인하기.
22. 문제에서 정해진 제한사항(조건) 외에는, 모든 제한이 없다고 생각하자. 고로 어떤 조건을 읽으면 어떤게 가능한지 생각해보기 ex) 모든 이들의 출발지는 다르다. 모든 이들은
    출발지와 목적지가 다르다 -> (1) 각각 승객의 출발지가 전부 다름 (2) 각각 승객들의 출발지와 목적지는 다름 (3) 목적지는 같을 수 있음!
23. 동시 vs 순차: 동시는 사건이 모두 일어나 후 이를 반영(다른 곳에 저장하고 반영하는게 편함), (별말 없으면 동시라고 생각) vs 순차는 현재 일어난 일이 다음에 영향을 끼침. 그대로 하면 됨
24. 변수 명은 모두 다르게 하자!!!
25. 경계에 더하거나 뺄 때는 중복해서 빼지 않았는지, 겹치는 부분이 없었는지 항상 고려해라.(꼭짓점 등)
26. 무언가 더하거나 뺄 땐 '한번만, 잘' 했는지 검토하기
27. 알고리즘 짤 때는 자료형까지 신경쓰자. 매핑 잘못되면 진짜 돌이킬 수 없다. 주고받는 값과 다루는 값이 자료형에 맞는지 검토하고 짜자. 알고리즘 -> 데이터 -> 함수 순으로
28. 함수는 만들면 무 조 건 적합성 판단하고 사용하자
29. dfs 짤땐 for로 돌릴지, 한 단계씩 내려갈지 정하자.
30. 겹치면 안돼 -> visit 겹쳐도 돼 -> 리스트 짜거나 위치만 기록
31. 모두 방문 했는지랑 방문 가능한지는 다르다. 방문 했는지는 1 사이클, 2 사이클이 별개인데 모두 방문하면 True 하지만 방문 가능한지는 1, 2 사이클이 독립이기때문에 False
    따라서 모두 방문 가능한지 판단하려면 사이클 판정을 하거나 탐색을 해야됨
32. 큐보단 리스트 인덱스 접근이, 리스트보단 변수 사용이 시간을 단축시킨다. 추가로 모든 함수를 메인에 작성하면 더 단축 가능. 시간 빡빡하면 갖가지 방법 사용하자
33. 범위가 너무 크거나 시간이 부족한 경우에, 특정 값을 찾는 문제라면 이분탐색을 고민해보자
34. 최소비용(최소 거리는 bfs지만, 간선마다 가중치가 다르다면 다익스트라 고려)은 다익스트라 생각해보자
35. 분명 BFS인데 메모리나 시간이 부족할거 같으면, 끄트머리만 저장해서 해결가능. 이미 이동한 칸은 조사하지 말고, 최대한 모든 칸을 한번만 방문하도록 짜보자.
